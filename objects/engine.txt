--@name engine
--@author Tyunge [ STEAM_0:0:78909614 ]
--@include simulated_engine/objects/component.txt
--@server
dofile("simulated_engine/objects/component.txt")

Engine = class("Engine",Component)
function Engine:initialize(wirelink,config)
    self.wirelink = wirelink
    self.entity = self.wirelink:entity()
    self.config = config
    self.components = {}
    
    
    self.fwRadius = 0.131675 -- meters
    self.fwMass = self.config.fwMass
    self.fwTorque = 0
    self.inertia = (self.fwMass*(self.fwRadius^2))/2
    
    self.lastCutOff = timer.curtime()
    
    self.throttle = 0
    
    
    self.rpm = 0
    
    self.clutchInputRPM = 0
    self.clutchOutputRPM = 0
    
    self.lastCheckedTorqueDifference = 0
     
    self.outputTorque = 0
    
    self.snd = nil
    
    if self.entity != nil then
        self.snd = sound.create(self.entity,"acf_base/engines/i5_petrolsmall.wav")
            self.snd:play()
            self.snd:setVolume(0)
    end
    
    self:printEngineInfo()

end


function Engine:think()
    local transmission = self:getTransmission()
 
    
    if not transmission:clutchEngaged() or not transmission:inGear() then
        //Engine is not connected to transmission
        
        //Clutch Input RPM
        local engineAcceleration = math.rad( self.outputTorque/(self.inertia/2) )
        local engineDeceleration = ((self.clutchInputRPM*self.fwRadius)/self.fwMass)*(1-math.sign(self.outputTorque))
        
        self.clutchInputRPM = self.clutchInputRPM+(engineAcceleration-engineDeceleration)
        self.clutchInputRPM = math.max( self.config["idle"], self.clutchInputRPM )    
        
        
        self.outputTorque = self:calculateTorque(self.clutchInputRPM)
        
    else

            
        local rpmDifference = self.clutchInputRPM - self.clutchOutputRPM
        local torqueDifference = self:calculateTorque( math.abs(rpmDifference) )*math.sign(rpmDifference)
            
            
        local deltaTorqueDifference = torqueDifference - self.lastCheckedTorqueDifference
        self.lastCheckedTorqueDifference = torqueDifference

        local inputRPMAcceleration = math.rad( (torqueDifference-deltaTorqueDifference) /self.inertia )
            
            
        local factor = (rpmDifference/self.clutchInputRPM)

        
        self.clutchInputRPM = (self.clutchInputRPM*factor)+(self.clutchOutputRPM*(1-factor))
        self.outputTorque = self:calculateTorque(self.clutchInputRPM)
        
    end
        
    
    transmission:setInputTorque(self.outputTorque)

    //Clutch OutputRPM 
    self.clutchOutputRPM = transmission:getGearRPM()   
    self.rpm = math.min( self.config["redline"], self.clutchInputRPM)
    self:updateSounds()

    
end

function Engine:printEngineInfo()
    local torqueGraph = self.config["tqGraph"]

    local hpInfo = {
        peakHP = 0,
        atRPM = 0
    }
    
    local tqInfo = {
        peakTq = 0,
        atRPM = 0
    }

    for index, point in pairs(torqueGraph) do
        local rpm = (index/#torqueGraph)*self.config["redline"]
        
        local tq = self.config["pkTorque"]*point
        
        local hp = tq*rpm/5252
        
        if tq > tqInfo.peakTq then
            tqInfo.peakTq = tq
            tqInfo.atRPM = rpm
        end
        
        if hp > hpInfo.peakHP then
            hpInfo.peakHP = hp
            hpInfo.atRPM = rpm
        end
    end
    
    print(Color(150,255,255),"Engine Info:")
    print(Color(0,255,0), math.round(hpInfo.peakHP).."hp @ "..hpInfo.atRPM.."rpm")
    print(Color(255,150,0), math.round(tqInfo.peakTq).."ft-lb @ "..tqInfo.atRPM.."rpm")
    
end

//Simple sound FX
function Engine:updateSounds()
    local redline = self.config["redline"]
    local pkTorque = self.config["pkTorque"]
    local rpmRatio = self.rpm/redline
    
    //self.snd:setVolume( math.clamp(rpmRatio,0.1, (self.throttle*0.5)+0.25 ) )
    self.snd:setVolume( math.clamp( rpmRatio, 0.1, ((self.outputTorque/pkTorque)*0.5)+0.25 ) )
    self.snd:setPitch( rpmRatio*200, 0.1 )
end

/*
    Torque Curve calculation
    
    https://en.wikipedia.org/wiki/Cubic_Hermite_spline
    
    This is using a Hermite Curve interpolation to generate a torque curve.
    This works by splitting the rpm range from idle => redline into sections. 
    The number of section are the number of points in the torque graph divided in half
    Ex. 
        if you have 8 numbers in the torqueGraph table then the number of torque sections in the rpm range is 4.
    
    You can have as many points in the torque graph as long as it's an even number
    
    I chose this because it allows for any number of points while still producing a nice smooth curve    
*/
function Engine:calculateTorque(rpm)
    local powerCutOffTime = self.config["powerCutOffTime"]
    if timer.curtime() < self.lastCutOff+powerCutOffTime then return 0 end
    
    local torqueGraph = self.config["tqGraph"]
    local slope1, slope2 = 0, 0
    local rpmRatio = rpm/self.config.redline
    local numberOfTorquePoints = #torqueGraph
    local sections = numberOfTorquePoints/2
    
    local rpmSection = math.clamp( math.floor(rpmRatio*sections)+1, 1, sections )
    local rpmSectionRatio = (rpmRatio*sections)%1
    
    local torqueMin, torqueMax = torqueGraph[ (rpmSection*2)-1 ], torqueGraph[ (rpmSection*2) ]
    
    
    if rpmSection > 1 then
        slope1 = 0.5*(torqueGraph[rpmSection+1]-torqueGraph[rpmSection-1])
    else
        slope2 = torqueGraph[rpmSection+1]-torqueGraph[rpmSection]
    end
    
    
    if rpmSection < numberOfTorquePoints-2 then
        slope2 = 0.5*(torqueGraph[rpmSection+2]-torqueGraph[rpmSection])
    else
        slope2 = torqueGraph[rpmSection+1]-torqueGraph[rpmSection]
    end
    
    local torque = ( (2*(rpmSectionRatio^3)-3*(rpmSectionRatio^2)+1)*torqueMin + ( (rpmSectionRatio^3)-2*(rpmSectionRatio^2)+rpmSectionRatio )*slope1 + ( -2*(rpmSectionRatio^3)+3*(rpmSectionRatio^2) )*torqueMax + ( (rpmSectionRatio^3)-(rpmSectionRatio^2) )*slope2 )*(self.config.pkTorque*self.throttle)
    
    if self.rpm >= self.config.redline then
        self.lastCutOff = timer.curtime()
        //torque = 0
    end
    
    return torque 
end

function Engine:resetSounds()
    self.snd:destroy()
    self.snd = sound.create(self.entity,"acf_base/engines/i5_petrolsmall.wav")
        self.snd:play()
        self.snd:setVolume(0)
end

function Engine:getTransmission()
    return self:getComponents()[1]
end

function Engine:setThrottle(percent)
    self.throttle = math.clamp(percent, 0, 1)
end
